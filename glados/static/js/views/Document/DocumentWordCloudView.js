// Generated by CoffeeScript 1.4.0
var DocumentWordCloudView;

DocumentWordCloudView = CardView.extend(ResponsiviseViewExt).extend({
  initialize: function() {
    var updateViewProxy;
    updateViewProxy = this.setUpResponsiveRender();
    this.model.on('change', updateViewProxy, this);
    this.resource_type = 'Document';
    this.$vis_elem = $('#BCK-DocWordCloud');
    return this.firstTimeRender = true;
  },
  render: function() {
    var $description, $template;
    if (this.firstTimeRender) {
      this.$vis_elem.html('<i class="fa fa-cog fa-spin fa-2x fa-fw" aria-hidden="true"></i><span class="sr-only">Loading Visualisation...</span><br>');
      this.showCardContent();
      this.firstTimeRender = false;
      _.delay($.proxy(this.render, this), Settings.RESPONSIVE_REPAINT_WAIT * 2);
      return;
    }
    $description = $(this.el).find('.card-description');
    $template = $('#' + $description.attr('data-hb-template'));
    $description.html(Handlebars.compile($template.html())({
      document_chembl_id: this.model.get('document_chembl_id')
    }));
    this.showCardContent();
    this.initEmbedModal('word_cloud');
    this.activateModals();
    return this.paintWordCloud();
  },
  paintWordCloud: function() {
    var K, canvasElem, config, currentRange, desiredMaxWidth, desiredPercentaje, elemID, elemWidth, getColourFor, getFontSizeFor, highestValue, highestValueWords, highestWordLength, itOverlaps, lowestValue, maxFontLimit, maxFontSize, minFont, minFontSize, value, word, wordCharNum, wordIndex, wordList, wordVal, _i, _j, _k, _len, _len1, _len2;
    elemID = this.$vis_elem.attr('id');
    elemWidth = this.$vis_elem.width();
    this.$vis_elem.height(elemWidth * 0.5);
    K = 0.54;
    wordList = this.model.get('word_list');
    highestValueWords = [];
    highestValue = 0;
    highestWordLength = 0;
    lowestValue = Number.MAX_VALUE;
    for (_i = 0, _len = wordList.length; _i < _len; _i++) {
      wordVal = wordList[_i];
      word = wordVal[0];
      wordCharNum = word.length;
      value = wordVal[1];
      if (value > highestValue) {
        highestValue = value;
        highestValueWords = [];
        highestValueWords.push(word);
        highestWordLength = wordCharNum;
      } else if (value === highestValue) {
        highestValueWords.push(word);
        if (wordCharNum > highestWordLength) {
          highestWordLength = wordCharNum;
        }
      } else {
        lowestValue = value;
      }
    }
    desiredPercentaje = 0.9;
    desiredMaxWidth = desiredPercentaje * elemWidth;
    maxFontSize = parseInt(desiredMaxWidth / (K * highestWordLength));
    minFontSize = 10;
    getFontSizeFor = d3.scale.linear().domain([lowestValue, highestValue]).range([minFontSize, maxFontSize]).clamp(true);
    maxFontLimit = minFontSize * 2;
    itOverlaps = function(wordVal) {
      var assignedFontSize, numChars, wordSize;
      word = wordVal[0];
      value = wordVal[1];
      assignedFontSize = getFontSizeFor(value);
      numChars = word.length;
      wordSize = assignedFontSize * K * numChars;
      if (wordSize > elemWidth * desiredPercentaje) {
        return true;
      } else {
        return false;
      }
    };
    for (_j = 0, _len1 = wordList.length; _j < _len1; _j++) {
      wordVal = wordList[_j];
      while (itOverlaps(wordVal)) {
        currentRange = getFontSizeFor.range();
        minFont = currentRange[0];
        maxFontSize = 0.9 * maxFontSize;
        if (maxFontSize < maxFontLimit) {
          break;
        }
        getFontSizeFor.range([minFont, maxFontSize]);
        console.log('reset');
      }
    }
    getColourFor = d3.scale.linear().domain([minFontSize, maxFontSize]).interpolate(d3.interpolateHcl).range([d3.rgb(Settings.VISUALISATION_TEAL_MIN), d3.rgb(Settings.VISUALISATION_TEAL_MAX)]);
    for (_k = 0, _len2 = wordList.length; _k < _len2; _k++) {
      wordVal = wordList[_k];
      wordVal[1] = getFontSizeFor(wordVal[1]);
    }
    wordIndex = _.indexBy(wordList, 0);
    config = {
      list: wordList,
      fontFamily: "Roboto Mono",
      drawOutOfBound: true,
      color: function(word, fontSize) {
        return getColourFor(fontSize);
      },
      rotateRatio: 0.0,
      classes: 'wordcloud-word',
      backgroundColor: Settings.VISUALISATION_CARD_GREY
    };
    canvasElem = document.getElementById(elemID);
    WordCloud(canvasElem, config);
    return $(canvasElem).on('wordcloudstop', function() {
      return $(this).find('.wordcloud-word').addClass('tooltiped').attr('data-position', 'bottom').attr('data-tooltip', function() {
        var text;
        text = $(this).text();
        value = wordIndex[text][1];
        return 'Score: ' + getFontSizeFor.invert(Number(value)).toFixed(6);
      }).tooltip().click(function() {
        var termEncoded;
        termEncoded = decodeURIComponent($(this).text());
        return window.open('/documents_with_same_terms/' + termEncoded, '_blank');
      });
    });
  }
});
